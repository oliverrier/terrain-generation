#pragma once

#include <GL/glew.h>
#include <SFML/OpenGL.hpp>

#include <vector>
#include <array>

#include "utils/math/Math.h"
#include "engine/graphics/shaders/Shader.h"

constexpr float MAP_SIZE = 5;

template<typename Type>
struct vertex_struct_map
{
	vertex_struct_map(const Point3d<Type>& p_, const Point3d<Type>& n_, const Color<Type>& c_) : pointCoords(p_), color(c_), normalVector(n_) {}
	Point3d<Type> pointCoords;
	Point3d<Type> normalVector;
	Color<Type> color; 

	int numberOfFaces = 0;
};

template<typename Type>
class Map {
public: 
	static_assert(std::is_arithmetic_v<Type>, "Type must be an arithmetic type.");

	Map()
		: _vao(0)
		, _vbo(0)
	{
		load();
	}

	~Map()
	{
		glDeleteVertexArrays(1, &_vao);
		glDeleteBuffers(1, &_vbo);
	}

	void generateVertices(int size, float step) {

		int numberOfVertices = static_cast<int>(size / step) + 1;

		const int mapHeight = numberOfVertices;
		const int mapWidth = numberOfVertices;

		std::vector<std::vector<Type>> elevationMap(mapHeight, std::vector<Type>(mapWidth));

		for (int h = 0; h < mapHeight; ++h) {
			for (int w = 0; w < mapWidth; ++w) {
				int newWidth = w / mapWidth;
				int newHeight = h / mapHeight;
				elevationMap[newHeight][newWidth] = 0; // Need to be generated by PerlinNoise
			}
		}

		for (int i = 0; i < numberOfVertices; ++i) {
			for (int j = 0; j < numberOfVertices; ++j) {
				const Type x = i * step;
				const Type z = j * step;
				const Type y = elevationMap[z][x];
				_vertices.push_back(Point3d<Type>{x, y, z});
			}
		}

		// Generate indexes for vertice
		for (int i = 0; i < numberOfVertices - 1; ++i) {
			for (int j = 0; j < numberOfVertices - 1; ++j) {

				// Indices des sommets des deux triangles formant un carré
				const unsigned int index1 = i * numberOfVertices + j;
				const unsigned int index2 = index1 + 1;
				const unsigned int index3 = (i + 1) * numberOfVertices + j;
				const unsigned int index4 = index3 + 1;

				// Premier triangle
				_verticesIndexes.push_back(index1);
				_verticesIndexes.push_back(index2);
				_verticesIndexes.push_back(index3);

				// Deuxième triangle
				_verticesIndexes.push_back(index2);
				_verticesIndexes.push_back(index4);
				_verticesIndexes.push_back(index3);
			}
		}

	}

	void load() {
		
		// We want only one buffer with the id generated and stored in _vao
		glGenVertexArrays(1, &_vao);

		// create a new active VAO
		glBindVertexArray(_vao);

		// we want only one buffer with the id generated and stored in _vbo
		glGenBuffers(1, &_vbo);

		// 1. create a new active VBO if doesn’t exist
		// 2. if the VBO is active it will make it active
		// 3. if binded to 0, OpenGL stops
		glBindBuffer(GL_ARRAY_BUFFER, _vbo);

		Color<Type> greenColor{ 0, 1, 0, 1 };
		Point3d<Type> YNormal{ 0, +1, 0 };

		using VertexStructMapType = vertex_struct_map<Type>;
		std::vector<VertexStructMapType> points;

		generateVertices(MAP_SIZE, 1);

		for (Point3d<Type>& vertex : _vertices)
		{
			points.push_back(VertexStructMapType{ vertex, YNormal, greenColor });
		}

		_numberOfVertices = static_cast<GLsizei>(points.size());

		for (int i = 2; i < _verticesIndexes.size(); i += 3) {

			int index = _verticesIndexes.at(i);
			VertexStructMapType& point3 = points.at(_verticesIndexes.at(i));
			VertexStructMapType& point2 = points.at(_verticesIndexes.at(i - 1));
			VertexStructMapType& point1 = points.at(_verticesIndexes.at(i - 2));

			//calculate vector
			Point3d<Type> vector12 = { point2.pointCoords - point1.pointCoords };
			Point3d<Type> vector13 = { point3.pointCoords - point1.pointCoords };

			//Calculate normal
			Point3d<Type> normal =
			{
				(vector12.z * vector13.y) - (vector12.y * vector13.z),
				(vector12.x * vector13.z) - (vector12.z * vector13.x),
				(vector12.y * vector13.x) - (vector12.x * vector13.y)
			};

			Point3d<Type> point1Normal = point1.normalVector;
			Point3d<Type> point2Normal = point2.normalVector;
			Point3d<Type> point3Normal = point3.normalVector;

			point1Normal = ((point1Normal * point1.numberOfFaces) + normal) / (point1.numberOfFaces);
			point1Normal = point1Normal / std::sqrt((point1Normal.x * point1Normal.x) + (point1Normal.y * point1Normal.y) + (point1Normal.z * point1Normal.z));

			point1.numberOfFaces += 1;

			point2Normal = ((point2Normal * point2.numberOfFaces) + normal) / (point2.numberOfFaces);
			point2Normal = point2Normal / std::sqrt((point2Normal.x * point2Normal.x) + (point2Normal.y * point2Normal.y) + (point2Normal.z * point2Normal.z));

			point2.numberOfFaces += 1;

			point3Normal = ((point3Normal * point3.numberOfFaces) + normal) / (point3.numberOfFaces);
			point3Normal = point3Normal / std::sqrt((point3Normal.x * point3Normal.x) + (point3Normal.y * point3Normal.y) + (point3Normal.z * point3Normal.z));

			point3.numberOfFaces += 1;

			
		}

		glUseProgram(_program);

		// Allocate storage size units of OpenGL
		// Copy data from client to server
		glBufferData(GL_ARRAY_BUFFER, _numberOfVertices * sizeof(VertexStructMapType), points.data(), GL_STATIC_DRAW);

		ShaderInfo shaders[] = {
			{GL_VERTEX_SHADER, "assets/shaders/map.vert"},
			{GL_FRAGMENT_SHADER, "assets/shaders/map.frag"},
			{GL_NONE, nullptr},
		};

		_program = Shader::loadShaders(shaders);
		glUseProgram(_program);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VertexStructMapType), 0);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(VertexStructMapType), (char*)(0) + sizeof(VertexStructMapType::pointCoords));
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(VertexStructMapType), (char*)(0) + sizeof(VertexStructMapType::pointCoords) + sizeof(VertexStructMapType::normalVector));
		glEnableVertexAttribArray(2);


	}

	void render(const Mat4<Type>& ViewMatrix, const Mat4<Type>& ProjectionMatrix)
	{
		glUseProgram(_program);

		glBindVertexArray(_vao);

		Mat4<Type> ModelMatrix = Mat4<Type>::translation(0, 0, -5) * Mat4<Type>::rotationY(_angleX) * Mat4<Type>::rotationX(_angleY);

		glUniformMatrix4fv(glGetUniformLocation(_program, "ModelMatrix"), 1, GL_FALSE, ModelMatrix.getData());
		glUniformMatrix4fv(glGetUniformLocation(_program, "ViewMatrix"), 1, GL_FALSE, ViewMatrix.getData());
		glUniformMatrix4fv(glGetUniformLocation(_program, "ProjectionMatrix"), 1, GL_FALSE, ProjectionMatrix.getData());

		glUniform1f(glGetUniformLocation(_program, "material.ambient"), 0.3f);
		glUniform1f(glGetUniformLocation(_program, "material.diffuse"), 0.7f);
		glUniform1f(glGetUniformLocation(_program, "material.specular"), 1.f);
		glUniform1f(glGetUniformLocation(_program, "material.specularSmoothness"), 2.0f);

		glUniform3f(glGetUniformLocation(_program, "light.direction"), 0.f, -1.f, 0.f);
		glUniform3f(glGetUniformLocation(_program, "light.color"), 1.f, 1.f, 1.f);

		glUniform3f(glGetUniformLocation(_program, "camera.worldPosition"), 0.f, 0.f, 0.f);

		glDrawArrays(GL_TRIANGLES, 0, _numberOfVertices);
	}

	void update()
	{
	}



private:
	Type _angleX = 0;
	Type _angleY = 0;
	GLuint _vao = 0;
	GLuint _vbo = 0;
	GLuint _program;
	GLsizei _numberOfVertices;

	std::vector<Point3d<Type>> _vertices;
	std::vector<unsigned int> _verticesIndexes;

};